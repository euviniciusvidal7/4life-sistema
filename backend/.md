### 4Life Sistema — Guia de Implementação do Frontend (passo a passo)

Este guia documenta a lógica estrutural do projeto e descreve, em etapas, como integrar cada parte do frontend com o backend (Express + Supabase) e com os serviços auxiliares (SSE, Trello e rastreamento).

---

## 0) Pré‑requisitos e variáveis de ambiente

- Backend (.env)
  - SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, JWT_SECRET
  - PASTA_LEADS=C:/Users/Usuario/Desktop/4lifesistema/4life-sistema/leads
  - (opcional) DELAY_PROCESSAMENTO=600000
  - TRELLO_KEY, TRELLO_TOKEN
  - TRELLO_LIST_CONFIRMADOS (se usar no backend)

- Frontend (.env.local)
  - NEXT_PUBLIC_API_URL=http://localhost:3001
  - TRELLO_KEY, TRELLO_TOKEN
  - TRELLO_LIST_PRONTO_ENVIO=67f70b1e66425a64aa863ea0
  - TRELLO_LIST_EM_TRANSITO=67f70b1e66425a64aa863ea1
  - TRELLO_LIST_ENTREGUE_PAGO=67f71b2d0034671f377035e8
  - TRELLO_LIST_DEVOLVIDOS=6808cff12b9ae87d1d519329
  - TRELLO_LIST_CLIENTES_A_LIGAR=67fe3f6feeaedb56af382407

---

## 1) Modelos (Supabase) e contrato de dados

- `public.leads` (principal)
  - Campos relevantes: id, nome, contato, endereco, problema_relatado, pacote_escolhido, valor_final, rec (boolean), tipo_lead, status, vendedor_id, data_distribuicao, data_confirmacao, arquivo_original, hash_conteudo
  - status: 'disponivel' | 'aguardando' | 'distribuido' | 'em_andamento' | 'finalizado' | 'lixeira' | 'novo_cliente'
  - tipo_lead: 'recuperacao' | 'venda_concluida' | 'novo_lead'

- `public.lead_distribuicoes`: histórico de distribuição
- `public.novos_clientes`: registro após confirmação
- `public.distribuicao_config`: pesos por vendedor e tipo de lead
- `public.sistema_config`: chaves do sistema (ex.: distribuição automática)
- `public.online_sessions`: presença online simples

Observação: Para escala, recomenda‑se `public.leads_queue` (fila leve) para consumo de distribuição.

---

## 2) Autenticação (frontend)

1. Página `/login`:
   - POST `${NEXT_PUBLIC_API_URL}/api/auth/login` → `{ token, user }`.
   - Guardar em `localStorage`: `token`, `user`, `cargo`.
   - Redirecionar para `/dashboard`.

2. `ProtectedRoute`:
   - Ao montar, valida `token` via POST `/api/auth/verify`.
   - Em falha, limpar storage e redirecionar para `/login`.

3. Heartbeat (vendedor):
   - A cada 60s, POST `/api/auth/heartbeat` para manter presença.

---

## 3) SSE e presença (vendedor)

- SSE: GET `${NEXT_PUBLIC_API_URL}/api/leads/events?token=<JWT>`
  - Recebe `hello` e `lead_assigned`.
  - Em cada evento, recarregar listas do vendedor (~15s polling + SSE é suficiente).

- Presença admin (SSE):
  - GET `/api/admin/events/stream` → evento `presence` quando vendedores alternam online/offline.

---

## 4) Dashboard do Admin (dados e ações)

- GET `/api/admin/services/stats` → blocos:
  - `serviceStats`: totais (leads disponíveis, vendedores online, da pasta, por tipo)
  - `fileWatcherStats`: pasta monitorada, delay, processados
  - `distributionStats`: total, auto, manual, por vendedor
  - `fileWatcherStatus`: running | stopped
  - `logistica`: contagens por listas Trello (PRONTO → TRANSITO → ENTREGUE/DEVOLVIDOS → CLIENTES A LIGAR)

- Ações:
  - POST `/api/admin/services/process-existing` → ingerir arquivos atuais da pasta `@leads/`.
  - POST `/api/admin/distribution/manual-batch` → distribuir em lote (ponderado por configuração, sem delay).
  - POST `/api/admin/distribution/process-queue` → redistribuir fila 'aguardando'.
  - GET/POST `/api/admin/distribution/config` → pesos por vendedor e tipo.
  - POST `/api/admin/distribution/toggle` → auto on/off.
  - POST `/api/admin/services/filewatcher/start|stop` → controlar watcher.

---

## 5) Páginas do Vendedor (fluxos)

### 5.1 Recuperação (`/vendedor/recuperacao`)

- GET `/api/leads/meus?status=distribuido&tipo=recuperacao`.
- Botões:
  - Confirmar → POST `/api/leads/confirmar` { leadId }.
  - Lixeira → POST `/api/leads/lixeira` { leadId }.
- SSE/auto refresh para reatividade.

### 5.2 Novos Clientes (Vendidos) (`/vendedor/novos-clientes`)

- GET `/api/leads/meus?status=distribuido&tipo=vendido`.
- Ações:
  - Confirmar (individual) → POST `/api/leads/confirmar`.
  - Processar Todos (confirmar em lote) → iterar e chamar POST `/api/leads/confirmar` para cada item listado.

### 5.3 PRONTO PARA ENVIO (Confirmados) (`/vendedor/novo-cliente`)

- GET `/api/leads/meus?status=novo_cliente`.
- Ação manual (logística):
  - Botão “Processar (EM TRANSITO)” → POST `/api/logistica/mover` (frontend API) body: `{ target: 'EM_TRANSITO', lead: { id, nome, contato } }`.
  - A rota local encontra o card na lista Trello **PRONTO PARA ENVIO** e o move para **EM TRANSITO**.

---

## 6) Logística (Trello)

### 6.1 Utilitário (frontend `src/lib/trello.ts`)

- Funções:
  - `getListCards(listId)` → lista cards.
  - `moveCardToList(cardId, listId)` → move card.
  - `updateCardDesc(cardId, desc)` → atualiza descrição.
  - `resolveTargetListByEvento(codigoEvento)` → EMZ/EMI/EMH|ΕΜΗ|EMV → listas.
  - `LISTS` com ids das listas do `.env.local`.

### 6.2 Rotas API (frontend)

- `GET/POST /api/logistica/sincronizar`
  - Lê cards na lista **PRONTO PARA ENVIO**.
  - Para cada card, extrai NObjecto e chama `consultarStatus` (mock em `lib/rastreamento.js` ou SOAP real).
  - Move para a lista destino por evento (EMZ→TRANSITO, EMI→ENTREGUE, EMH/ΕΜΗ/EMV→DEVOLVIDOS). Em DEVOLVIDOS, anexa nota na descrição.
  - Retorna resumo `{ status, moved_cards, skipped, errors, details }`.

- `POST /api/logistica/mover`
  - body: `{ target: 'EM_TRANSITO'|'ENTREGUE_PAGO'|'DEVOLVIDOS', lead: { id, nome, contato } }`.
  - Procura card do lead em **PRONTO PARA ENVIO** e move para a lista indicada.

### 6.3 Backend (confirmação)

- Ao confirmar lead (vendedor), backend cria card no Trello com todos os dados do lead, na lista **PRONTO PARA ENVIO**.

---

## 7) Estados e transições (do lead)

- Ingestão: `status='disponivel'` → (fila/tempo) → distribuição → `status='distribuido'` + `vendedor_id`.
- Visualização no vendedor:
  - `rec=true` → aba Recuperação.
  - `rec=false` → aba Novos Clientes (Vendidos).
- Confirmação: `status='novo_cliente'` e registro em `novos_clientes` → card Trello em **PRONTO PARA ENVIO**.
- Logística manual: **PRONTO PARA ENVIO** → (**Processar**) → **EM TRANSITO** → (**Processar**) → **ENTREGUE - PAGO** / **DEVOLVIDOS**.
- Logística automática: `/api/logistica/sincronizar` faz o mesmo baseado no tracking (CTT).

---

## 8) Passos de implementação (checklist)

1. Autenticação
   - Implementar `/login` → guardar token e `ProtectedRoute` em todas as páginas.
   - Heartbeat a cada 60s em páginas do vendedor.

2. SSE (vendedor)
   - Conectar `EventSource` → `/api/leads/events?token=...`.
   - No evento `lead_assigned`, recarregar listas.

3. Painel Admin
   - Consumir `/api/admin/services/stats` e exibir: serviço, distribuição, filewatcher e logística.
   - Botões: process‑existing, distribuir agora, redistribuir fila, toggle auto.

4. Vendedor: Recuperação / Novos Clientes (Vendidos)
   - Listar com filtros de query.
   - Implementar Confirmar e Lixeira; em “Vendidos”, Processar Todos.

5. Vendedor: PRONTO PARA ENVIO (Confirmados)
   - Listar `status=novo_cliente`.
   - Implementar botão “Processar (EM TRANSITO)” chamando `/api/logistica/mover`.

6. Logística automática
   - Agendar chamada periódica (cron externo) para `/api/logistica/sincronizar`.
   - Integrar o `consultarStatus` com o serviço real de rastreamento (substituir mock por SOAP/WS conforme documentação dos CTT).

7. Erros e telemetria
   - Exibir toast/alertas para respostas não OK.
   - Validar origens CORS (backend) para SSE e APIs.

---

## 9) Diagrama do fluxo

```mermaid
flowchart LR
  subgraph Ingestão
    A["Pasta @leads/ (JSON)"] --> B[FileWatcher]
    B --> C["Supabase: public.leads (status='disponivel')"]
    C --> D["Trigger → public.leads_queue (lead_id, rec, tipo)"]
  end

  subgraph Distribuição
    D --> E{Modo}
    E -- Manual (Admin) --> F[distribuirLeadsEmLote]
    E -- Automático (Watcher) --> G[distribuirLeadAutomaticamente]
    F --> H["Escolha vendedor (distribuicao_config)"]
    G --> H
    H --> I["Update leads: status='distribuido', vendedor_id, data_distribuicao"]
    I --> J["Insert public.lead_distribuicoes"]
    I --> K["SSE → /api/leads/events"]
  end

  subgraph Vendedor
    K --> L["/vendedor/recuperacao (rec=true)"]
    K --> M["/vendedor/novos-clientes (rec=false)"]
    L --> N[POST /api/leads/confirmar]
    M --> N
  end
```

---

## 10) Endpoints (referência rápida)

- Auth: `/api/auth/login|verify|logout|heartbeat|users|create-user`
- Leads (vendedor): `/api/leads/meus`, `/api/leads/confirmar`, `/api/leads/lixeira`, `/api/leads/events` (SSE)
- Admin: `/api/admin/services/stats|process-existing|filewatcher/*|distribution/*` e `events/stream` (SSE)
- Logística (frontend API): `/api/logistica/sincronizar`, `/api/logistica/mover`

---

## 11) Erros comuns e soluções

- “Não lista arquivos da pasta” → verifique `PASTA_LEADS` no backend, logs do FileWatcher e use “Processar Arquivos Existentes”.
- “Insert falha por CHECK de status/tipo” → alinhar CHECKs (ver schema do projeto) para aceitar 'disponivel' e 'novo_cliente'.
- “SSE bloqueado por CORS” → garanta headers CORS também em 401/erros de `/api/leads/events`.
- “Card Trello não encontrado” → padronize o título/descrição com `lead.id`, `nome` e `contato` para facilitar matching.

---

## 12) Observações finais

- O frontend deve tratar os estados declarados (status + rec) e respeitar as transições. O designer pode reorganizar as telas, desde que os contratos/rotas acima sejam mantidos.
- Para grandes volumes de leads, adotar `public.leads_queue` e movimentação por lote — o frontend não muda; apenas consome os mesmos endpoints.


