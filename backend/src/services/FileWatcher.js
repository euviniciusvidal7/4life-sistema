const chokidar = require('chokidar');
const fs = require('fs-extra');
const path = require('path');
const { createClient } = require('@supabase/supabase-js');
const logger = require('../utils/logger');
const LeadDistributor = require('./LeadDistributor');

class FileWatcher {
    constructor() {
        // A resolu√ß√£o do caminho ser√° feita dinamicamente em ensureLeadsFolder()
        this.pastaLeads = process.env.PASTA_LEADS || path.join(process.cwd(), 'leads');
        this.delayProcessamento = parseInt(process.env.DELAY_PROCESSAMENTO) || 600000; // 10 minutos
        this.watcher = null;
        this.supabase = createClient(
            process.env.SUPABASE_URL,
            process.env.SUPABASE_SERVICE_ROLE_KEY
        );
        this.leadDistributor = new LeadDistributor();
        this.processedFiles = new Set();
    }

    async iniciar() {
        try {
            // Verificar/criar pasta com fallback em caso de permiss√£o inv√°lida
            await this.ensureLeadsFolder();

            // Configurar o watcher
            this.watcher = chokidar.watch(this.pastaLeads, {
                ignored: /(^|[\/\\])\../, // Ignorar arquivos ocultos
                persistent: true,
                awaitWriteFinish: {
                    stabilityThreshold: 2000,
                    pollInterval: 100
                }
            });

            // Eventos do watcher
            this.watcher
                .on('add', (filePath) => this.handleNewFile(filePath))
                .on('change', (filePath) => this.handleFileChange(filePath))
                .on('unlink', (filePath) => this.handleFileDelete(filePath))
                .on('error', (error) => logger.error('Erro no FileWatcher:', error))
                .on('ready', () => {
                    logger.info('üîç FileWatcher iniciado e monitorando pasta de leads');
                    logger.info(`‚è∞ Delay de processamento: ${this.delayProcessamento / 1000} segundos`);
                });

        } catch (error) {
            logger.error('Erro ao iniciar FileWatcher:', error);
            throw error;
        }
    }

    async ensureLeadsFolder() {
        // 1) Se PASTA_LEADS foi definida, exigir que exista (n√£o criar, n√£o fazer fallback silencioso)
        if (process.env.PASTA_LEADS) {
            const explicit = process.env.PASTA_LEADS.trim();
            const exists = await fs.pathExists(explicit);
            if (!exists) {
                const msg = `PASTA_LEADS apontada no .env n√£o existe: ${explicit}`;
                logger.error(`‚ùå ${msg}`);
                throw new Error(msg);
            }
            const stat = await fs.stat(explicit);
            if (!stat.isDirectory()) {
                const msg = `PASTA_LEADS n√£o √© um diret√≥rio: ${explicit}`;
                logger.error(`‚ùå ${msg}`);
                throw new Error(msg);
            }
            this.pastaLeads = explicit;
            logger.info(`üìÅ Pasta de leads configurada: ${this.pastaLeads}`);
            return;
        }

        // 2) Descoberta autom√°tica quando n√£o h√° PASTA_LEADS
        const candidates = [
            path.join(process.cwd(), 'leads'),
            path.resolve(process.cwd(), '..', 'leads'),
            path.join(path.resolve(__dirname, '..', '..', '..'), 'leads'),
        ];

        let lastError = null;
        for (const candidate of candidates) {
            try {
                await fs.ensureDir(candidate);
                this.pastaLeads = candidate;
                logger.info(`üìÅ Pasta de leads configurada: ${this.pastaLeads}`);
                return;
            } catch (err) {
                lastError = err;
                if (['EPERM', 'EACCES', 'EEXIST'].includes(err?.code)) {
                    logger.warn(`‚ö†Ô∏è Sem acesso √† pasta de leads: ${candidate}. Tentando pr√≥ximo caminho...`);
                    continue;
                }
            }
        }

        logger.error('‚ùå Nenhum caminho v√°lido para a pasta de leads p√¥de ser preparado.');
        if (lastError) logger.error('√öltimo erro:', lastError);
        throw lastError || new Error('Falha ao preparar pasta de leads');
    }

    async handleNewFile(filePath) {
        try {
            // Verificar se √© um arquivo JSON
            if (!filePath.endsWith('.json')) {
                logger.info(`üìÑ Arquivo ignorado (n√£o √© JSON): ${path.basename(filePath)}`);
                return;
            }

            // Verificar se j√° foi processado
            if (this.processedFiles.has(filePath)) {
                logger.info(`üîÑ Arquivo j√° processado: ${path.basename(filePath)}`);
                return;
            }

            logger.info(`üìÑ Novo arquivo detectado: ${path.basename(filePath)}`);

            // Aguardar o delay de processamento
            setTimeout(async () => {
                await this.processarLead(filePath);
            }, this.delayProcessamento);

        } catch (error) {
            logger.error('Erro ao processar novo arquivo:', error);
        }
    }

    async handleFileChange(filePath) {
        try {
            if (!filePath.endsWith('.json')) return;

            logger.info(`üìù Arquivo modificado: ${path.basename(filePath)}`);
            
            // Reprocessar ap√≥s delay
            setTimeout(async () => {
                await this.processarLead(filePath);
            }, this.delayProcessamento);

        } catch (error) {
            logger.error('Erro ao processar arquivo modificado:', error);
        }
    }

    async handleFileDelete(filePath) {
        try {
            if (!filePath.endsWith('.json')) return;

            logger.info(`üóëÔ∏è Arquivo removido: ${path.basename(filePath)}`);
            this.processedFiles.delete(filePath);

        } catch (error) {
            logger.error('Erro ao processar remo√ß√£o de arquivo:', error);
        }
    }

    async processarLead(filePath) {
        try {
            // Verificar se arquivo ainda existe
            if (!await fs.pathExists(filePath)) {
                logger.warn(`‚ö†Ô∏è Arquivo n√£o encontrado: ${path.basename(filePath)}`);
                return;
            }

            // Ler o arquivo JSON
            const fileContent = await fs.readFile(filePath, 'utf8');
            const leadData = JSON.parse(fileContent);

            logger.info(`üîç Processando lead: ${path.basename(filePath)}`);

            // Validar dados do lead
            const leadValidado = this.validarLead(leadData);
            if (!leadValidado) {
                logger.error(`‚ùå Lead inv√°lido: ${path.basename(filePath)}`);
                return;
            }

            // Determinar tipo de lead baseado na vari√°vel 'rec'
            const tipoLead = this.determinarTipoLead(leadData);

            // Salvar lead no banco de dados
            const leadSalvo = await this.salvarLead(leadData, tipoLead, path.basename(filePath));
            if (!leadSalvo) {
                logger.error(`‚ùå Erro ao salvar lead: ${path.basename(filePath)}`);
                return;
            }

            // Marcar como processado
            this.processedFiles.add(filePath);

            // Log de sucesso
            logger.leadProcessed({
                arquivo: path.basename(filePath),
                nome: leadData.NOME,
                tipo: tipoLead,
                rec: leadData.rec
            });

            // Verificar toggle de distribui√ß√£o autom√°tica
            let ativa = false;
            try {
                const { data: statusData } = await this.supabase
                    .from('sistema_config')
                    .select('valor')
                    .eq('chave', 'distribuicao_automatica')
                    .single();
                ativa = statusData?.valor === 'true';
            } catch (_) {}

            if (ativa) {
                await this.leadDistributor.distribuirLeadAutomaticamente(leadSalvo.id);
            } else {
                logger.info('üïí Distribui√ß√£o autom√°tica desativada. Lead mantido como disponivel.');
            }

            logger.info(`‚úÖ Lead processado com sucesso: ${path.basename(filePath)}`);

        } catch (error) {
            logger.error(`‚ùå Erro ao processar lead ${path.basename(filePath)}:`, error);
        }
    }

    validarLead(leadData) {
        try {
            // Campos obrigat√≥rios (ENDERE√áO pode n√£o existir em alguns fluxos)
            const camposObrigatorios = ['NOME', 'CONTATO', 'PROBLEMA_RELATADO'];
            
            for (const campo of camposObrigatorios) {
                if (!leadData[campo]) {
                    logger.error(`Campo obrigat√≥rio ausente: ${campo}`);
                    return false;
                }
            }

            // Validar se 'rec' (ou 'Rec') existe como boolean
            const hasRecLower = typeof leadData.rec === 'boolean';
            const hasRecUpper = typeof leadData.Rec === 'boolean';
            if (!hasRecLower && !hasRecUpper) {
                logger.error('Campo "rec/Rec" deve ser boolean');
                return false;
            }

            return true;

        } catch (error) {
            logger.error('Erro na valida√ß√£o do lead:', error);
            return false;
        }
    }

    determinarTipoLead(leadData) {
        // L√≥gica baseada na vari√°vel 'rec' (aceitar rec ou Rec)
        const recValue = (typeof leadData.rec === 'boolean')
            ? leadData.rec
            : (typeof leadData.Rec === 'boolean' ? leadData.Rec : undefined);
        if (recValue === true) {
            return 'recuperacao';
        } else if (recValue === false) {
            return 'venda_concluida';
        } else {
            return 'novo_lead';
        }
    }

    async salvarLead(leadData, tipoLead, arquivoOriginal) {
        try {
            const leadParaSalvar = {
                nome: leadData.NOME || leadData.nome,
                endereco: leadData.ENDERE√áO || leadData.endereco,
                contato: leadData.CONTATO || leadData.contato,
                problema_relatado: leadData.PROBLEMA_RELATADO || leadData.problema_relatado,
                conversa_ia: leadData.CONVERSA_IA || leadData.conversa_ia || null,
                pacote_escolhido: leadData.PACOTE_ESCOLHIDO || leadData.pacote_escolhido || null,
                valor_final: leadData.VALOR_FINAL ? parseFloat(leadData.VALOR_FINAL) : (leadData.valor_final ? parseFloat(leadData.valor_final) : null),
                rec: (typeof leadData.rec === 'boolean') ? leadData.rec : (typeof leadData.Rec === 'boolean' ? leadData.Rec : false),
                tipo_lead: tipoLead,
                status: 'disponivel',
                arquivo_original: arquivoOriginal
            };

            const { data, error } = await this.supabase
                .from('leads')
                .insert([leadParaSalvar])
                .select()
                .single();

            if (error) {
                logger.error('Erro ao salvar lead no banco:', error);
                return null;
            }

            return data;
        } catch (error) {
            logger.error('Erro ao salvar lead:', error);
            return null;
        }
    }

    async parar() {
        try {
            if (this.watcher) {
                await this.watcher.close();
                logger.info('üõë FileWatcher parado');
            }
        } catch (error) {
            logger.error('Erro ao parar FileWatcher:', error);
        }
    }

    // M√©todo para processar arquivos existentes na pasta
    async processarArquivosExistentes() {
        try {
            logger.info('üîç Verificando arquivos existentes na pasta de leads...');
            // Revalidar o caminho antes de escanear (cobre cen√°rios onde .env mudou)
            await this.ensureLeadsFolder();
            logger.info(`üìÇ Pasta atual para varredura: ${this.pastaLeads}`);
            
            const arquivos = await fs.readdir(this.pastaLeads);
            const arquivosJson = arquivos.filter(arquivo => arquivo.endsWith('.json'));

            logger.info(`üìÑ Encontrados ${arquivosJson.length} arquivos JSON para processar`);

            for (const arquivo of arquivosJson) {
                const filePath = path.join(this.pastaLeads, arquivo);
                await this.processarLead(filePath);
            }

        } catch (error) {
            logger.error('Erro ao processar arquivos existentes:', error);
        }
    }

    // M√©todo para obter estat√≠sticas do FileWatcher
    getEstatisticas() {
        return {
            pastaMonitorada: this.pastaLeads,
            delayProcessamento: this.delayProcessamento,
            arquivosProcessados: this.processedFiles.size,
            arquivosEmMemoria: Array.from(this.processedFiles)
        };
    }
}

module.exports = FileWatcher;
